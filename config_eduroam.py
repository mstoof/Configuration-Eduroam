
import sys
import getpass
import re
import errno
import hashlib

graphical = "linux" in sys.platform  # op Linux is GUI de default
PROGRAM_NAME = "config_eduroam"
PROGRAM_VERSION = "v3.1"
DEFAULT_WPA_CONFIG = "/etc/wpa_supplicant/wpa_supplicant.conf"
if 'win' in sys.platform:
    wpa_config = "-"
else:    # er kan goed een lokale wpa_supplicant.conf aanwezig zijn
    wpa_config = DEFAULT_WPA_CONFIG
COPYRIGHT = "{} {}, Â©2018,2020 Hogeschool Utrecht\n".format(PROGRAM_NAME, PROGRAM_VERSION)
CONFIG_COMMENT_STUB = "# eduroam config generated by "
CONFIG_COMMENT = "\n{}{} {}".format(CONFIG_COMMENT_STUB, PROGRAM_NAME, PROGRAM_VERSION)

# Open het configuratiebestand om de bestaande configuratie in te lezen en
#   te controleren of er een oude (al dan niet werkende) eduroam
#   configuratie verwijderd moet worden
# Met behulp van reguliere expressies en hulpvariabelen wordt
#   de configuratiefile geparsed en vastgelegd waar een
#   eventuele eduroam configuratie zich bevindt.
eduroam = False

def usage():
    print(COPYRIGHT)
    print("Gebruik: {} [-c|-g|-h|-t] [-f <wpa config>]".format(sys.argv[0]))
    print("    -c of -t        : gebruik command line (tekst) interface")
    print("    -g              : gebruik grafische interface (default onder Linux)")
    print("    -f <wpa config> : welk bestand aanpassen")
    print("                      (default {};".format(DEFAULT_WPA_CONFIG))
    print("                       - voor stdout (toon op scherm))")
    print("    -h              : toon deze informatie")
    exit(0)
#fed usage

def show_status(statustext, emphasize=False):
    if graphical:
        if emphasize:
            bottom_label.config(text=statustext, fg='red')
        else:
            bottom_label.config(text=statustext)
    else:
        if emphasize:
            print("\a{}".format(statustext))
        else:
            print(statustext)
#fed show_status

def notify(message, error=False, warning=False):
    if graphical:
        if error:
            tkMessageBox.showerror(PROGRAM_NAME, message)
        else:
            tkMessageBox.showinfo(PROGRAM_NAME, message)
    else:
        print("\n\a{}".format(message))
#fed notify

def show_config(instruction_text, config_text):
    def close_config():
        root.quit()

    def hitenter(event):
        close_config()

    if graphical:
        instructions = tkinter.Label(master=main_frame, text=instruction_text)
        instructions.pack(padx=1, pady=1)
        bottom_frame = tkinter.Frame(master=main_frame)
        config = tkinter.Text(master=bottom_frame, height=15, width=80)
        config.grid(row=1, column=0, padx=20, pady=10)
        config.insert(tkinter.INSERT, config_text)
        config.config(state=tkinter.DISABLED, font=('Fixedsys', '10'))
        ok_button = tkinter.Button(master=bottom_frame,
                                   text='OK',
                                   default='active',
                                   command=close_config)
        ok_button.grid(row=1, column=1, padx=20, pady=10)
        ok_button.bind('<Return>', hitenter)
        ok_button.focus_force()

        bottom_frame.pack(padx=1, pady=1)
        root.mainloop()
    else:
        print("\n{}\n\n{}".format(instruction_text, config_text))
#fed show_config

def yes_no_question(question):
    global yes_no_click
    yes_no_click = None
    if graphical:
        def clicked_yes():
            global yes_no_click
            yes_no_click = True
            show_status('')  # maak statusbalk leeg
            root.quit()

        def clicked_no():
            global yes_no_click
            yes_no_click = False
            show_status('')  # maak statusbalk leeg
            root.quit()

        question_text = tkinter.Label(master=main_frame, text=question+'?')
        question_text.pack(padx=1, pady=1)
        bottom_frame = tkinter.Frame(master=main_frame)
        yes_button = tkinter.Button(master=bottom_frame,
                                    text='Ja',
                                    command=clicked_yes)
        yes_button.grid(row=0, column=0, padx=20, pady=10)
        no_button = tkinter.Button(master=bottom_frame,
                                   text='Nee',
                                   default='active',
                                   command=clicked_no)
        no_button.grid(row=0, column=1, padx=20, pady=10)
        no_button.focus_force()
        bottom_frame.pack(padx=1, pady=1)
        root.mainloop()

        # only reached when button has been clicked
        question_text.destroy()
        bottom_frame.destroy()

        return yes_no_click
    else:
        try:
            if sys.version_info.major == 2:
                # Python 2
                return "j" in raw_input(question+" (j/n)? ").lower()
            else:
                # Python 3
                return "j" in input(question+" (j/n)? ").lower()
        except (KeyboardInterrupt, EOFError):
            notify("\n\n{} afgebroken.".format(PROGRAM_NAME), True)
            exit(errno.EINTR)
    #fi graphical
#fed yes_no_question

def open_question(question):
    global answer
    answer = None

    if graphical:
        def clicked_ok():
            global answer
            answer = answertext.get()
            if answer:  # tekstveld is niet leeg gelaten
                show_status('')  # maak statusbalk leeg
                root.quit()
            else:
                show_status("Niets ingevuld", True)
        def hitenter(event):
            clicked_ok()

        question_text = tkinter.Label(master=main_frame, text=question)
        question_text.pack(padx=1, pady=1)
        bottom_frame = tkinter.Frame(master=main_frame)
        answertext = tkinter.Entry(master=bottom_frame, width=45)
        answertext.grid(row=0, column=0, padx=20, pady=10)
        answertext.bind('<Return>', hitenter)
        answertext.focus_force()
        ok_button = tkinter.Button(master=bottom_frame,
                                   text='OK',
                                   default='active',
                                   command=clicked_ok)
        ok_button.grid(row=0, column=1, padx=20, pady=10)
        ok_button.bind('<Return>', hitenter)

        bottom_frame.pack(padx=1, pady=1)
        root.mainloop()

        # only reached when answer has been given
        question_text.destroy()
        bottom_frame.destroy()

        return answer
    else:
        answer = ''
        try:
            while not answer:
                if sys.version_info.major == 2:
                    # Python 2
                    answer = raw_input(question)
                else:
                    # Python 3
                    answer = input(question)
                return answer
        except (KeyboardInterrupt, EOFError):
            notify("\n\n{} afgebroken.".format(PROGRAM_NAME), True)
            exit(errno.EINTR)
    #fi
#fed open_question

def nthash(password):
    # return Windows NT style hash,
    #     earlier versions used smbpasswd module or passlib.nthash module
    return hashlib.new('md4', password.encode('utf-16le')).hexdigest()
#fed nthash

def get_pwd_hash(question):
    global answer
    answer = None

    if graphical:
        def clicked_ok():
            global answer
            if first_answer.get():
                if first_answer.get() == second_answer.get():
                    answer = nthash(first_answer.get())
                    show_status('')  # maak statusbalk leeg
                    root.quit()
                else:
                 show_status("Passwords zijn niet gelijk, probeer opnieuw", True)
            else:
                show_status("Niets ingevuld", True)
        def hitenter(event):
            clicked_ok()

        question_text = tkinter.Label(master=main_frame, text=question)
        question_text.pack(padx=1, pady=1)
        bottom_frame = tkinter.Frame(master=main_frame)
        first_answer = tkinter.Entry(master=bottom_frame, show=u'\u2022', width=30)
        first_answer.grid(row=0, column=0, padx=20, pady=10)
        first_answer.focus_force()
        first_answer.bind('<Return>', lambda event: second_answer.focus_force())
        second_answer = tkinter.Entry(master=bottom_frame, show=u'\u2022', width=30)
        second_answer.grid(row=1, column=0, padx=20, pady=10)
        second_answer.bind('<Return>', hitenter)
        ok_button = tkinter.Button(master=bottom_frame,
                                   text='OK',
                                   default='active',
                                   command=clicked_ok)
        ok_button.grid(row=1, column=1, padx=20, pady=10)
        ok_button.bind('<Return>', hitenter)

        bottom_frame.pack(padx=1, pady=1)
        root.mainloop()

        # only reached when answer has been given
        question_text.destroy()
        bottom_frame.destroy()

        return answer
    else:  # not graphical
        # Blijf om paren wachtwoorden vragen tot de twee wachtwoorden met elkaar matchen
        while True:
            try:
                pwd_input = getpass.getpass(question)
                pwd_check = getpass.getpass("Herhaal wachtwoord: ")
            except (KeyboardInterrupt, EOFError):
                notify("\n\n{} afgebroken.".format(PROGRAM_NAME), True)
                exit(errno.EINTR)
            if pwd_input and pwd_input == pwd_check:
                # matchende wachtwoorden ingegeven, ga verder
                return nthash(pwd_input)
            else:
                show_status("De ingevoerde wachtwoorden zijn niet gelijk. Probeer het opnieuw", True)
    #fi
#fed get_pwd_hash

### MAIN

# controleer eventuele command line opties
while len(sys.argv) > 1:         # er zijn argumenten te verwerken
    if sys.argv[1] == "-c" or sys.argv[1] == "-t":  # c voor command line, t voor tekst
        graphical = False
    elif sys.argv[1] == "-g":    # g voor grafisch of GUI
        graphical = True
    elif sys.argv[1] == "-f":    # f voor file
        wpa_config = sys.argv[2]
        sys.argv = sys.argv[1:]  # shift
    else:                        # zowel -h als enige niet ondersteunde optie
        usage()
    sys.argv = sys.argv[1:]      # shift

# probeer in grafische modus eerst of GUI gestart kan worden
if graphical:
    try:
        if sys.version_info.major == 2:
            # Python 2
            import Tkinter as tkinter
            import tkMessageBox
        else:
            # Python 3
            import tkinter
            import tkinter.messagebox as tkMessageBox
    except ImportError:
        print("TKinter niet beschikbaar, val terug naar tekstinterface")
        graphical = False
#fi graphical

if graphical:  # niet aan vorige if vast vanwege mogelijk ontbreken TKinter
    try:
        root = tkinter.Tk()
        root.title(PROGRAM_NAME)
        # stel geschikt font in voor alle teksten
        root.option_add("*font", "\"Helvetica\" 11")
        main_frame = tkinter.Frame(master=root)
        main_frame.pack()
        bottom_label = tkinter.Label(master=root,
                                     bd=1,
                                     relief=tkinter.SUNKEN,
                                     anchor=tkinter.S)
        bottom_label.pack(fill=tkinter.X, expand=True, padx=1, pady=1)

        def on_closing():
            if tkMessageBox.askokcancel("Afbreken", "Wil je echt stoppen?"):
                    root.destroy()
                    exit()
        root.protocol("WM_DELETE_WINDOW", on_closing)
    except tkinter.TclError:
        # Geen X11 omgeving of geen toegang, gebruik command line interface
        print("Kon GUI niet starten, val terug naar tekstinterface")
        graphical = False
#fi graphical

show_status(COPYRIGHT)

if wpa_config != "-":
    delete_list = []  # list of old config lines to be deleted
    try:
        with open(wpa_config, "r") as f:
            all_lines = f.readlines()
            for linenr in range(len(all_lines)):
                if re.match("^{}".format(CONFIG_COMMENT_STUB), all_lines[linenr]):
                    if linenr > 0 and re.match("^$", all_lines[linenr-1]):
                        delete_list.insert(0, (linenr-1, linenr))
                    else:
                        delete_list.insert(0, (linenr, linenr))

                if re.match("[ \t]*network[ \t]*=[{][ \t]*$", all_lines[linenr]):
                    networkstart = linenr

                if re.match("[ \t]*ssid[ \t]*=[ \t]*\"eduroam\"[ \t]*$",
                            all_lines[linenr].lower()):
                    eduroam = True

                if eduroam and re.match("[ \t]*[}][ \t]*$", all_lines[linenr]):
                    # tel 1 op bij het regelnummer als er een lege regel volgt
                    #     (anders wordt bij herhaaldelijk gebruik van dit
                    #      script het configuratiebestand steeds langer met
                    #      lege regels)
                    if (linenr < len(all_lines) - 1
                            and re.match("^$", all_lines[linenr+1])):
                        networkend = linenr + 1
                    else:
                        networkend = linenr

                    # zet het hele blok met betrekking tot eduroam vooraan de
                    #     lijst van te verwijderen regels, zodat de laatste
                    #     regels het eerste weggaan (anders klopt gaandeweg de
                    #     telling niet meer)
                    delete_list.insert(0, (networkstart, networkend))

                    # reset eduroam hulpvariabele,
                    #     mogelijk zijn er meer eduroam blokken
                    eduroam = False

    except IOError as e:
        if e.errno == errno.ENOENT:
            if wpa_config == DEFAULT_WPA_CONFIG:
                notify("FOUT: Bestand {} niet gevonden.".format(wpa_config), True)
                exit(e.errno)
            else:
                show_status("WAARSCHUWING: Bestand {} {}"
                      	    	.format(wpa_config,
                                        "niet gevonden, begin met lege configuratie"))
        elif e.errno == errno.EACCES:
            notify("{}\n\n{} {} {}\n"
                       .format("FOUT: Kan bestand {} niet lezen.".format(wpa_config),
                               "Wordt het script wel met rootrechten gedraaid?",
                               "Dit kan met behulp van de applicatielink op de desktop,",
                               "met behulp van sudo of vanuit een root login."),
                   True)
            if wpa_config == DEFAULT_WPA_CONFIG:
                if yes_no_question("Doorgaan en benodigde wijziging alleen tonen in plaats van doorvoeren"):
                    wpa_config = "-"
                else:
                    exit(e.errno)
            else:
                exit(e.errno)
        else:
            raise

    # Schrijf het bestand zonder de oude eduroam configuratie alleen weg
    #   indien nodig, en met toestemming van de gebruiker
    if delete_list:  # list not empty
        if yes_no_question("{}\n{}\n{}"
                           .format("Er is een oude eduroam configuratie gevonden.",
                                   "Configuratie van andere netwerken blijft ongemoeid.",
                                   "Oude eduroam configuratie verwijderen")):
            for (begin, end) in delete_list:
                del all_lines[begin:end+1]
        else:
            notify("Programma afgebroken, er zijn geen wijzigingen aangebracht")
            exit()

        try:
            with open(wpa_config, "w") as f:
                for line in all_lines:
                    f.write(line)

        except IOError as e:
            if e.errno == errno.ENOENT:
                # Dit zou nu niet meer mogen gebeuren, er is al succesvol gelezen
                notify("FOUT: Bestand {} niet gevonden".format(wpa_config), True)
                exit(e.errno)
            elif e.errno == errno.EACCES:
                notify("FOUT: Kan bestand {} niet schrijven.\n{} {} {}"
                      .format(wpa_config,
                              "Wordt het script wel met rootrechten gedraaid?",
                              "Dit kan met behulp van de applicatielink op de desktop,",
                              "met behulp van sudo of vanuit een root login"), True)
                exit(e.errno)
            else:
                raise

        show_status("Oude Eduroam configuratie verwijderd.")
#fi wpa_config != "-":

# Vraag naar de Eduroam inloggegevens:
#   username bevat hierna de inlognaam
#   pwd_hash bevat hierna de password hash in NTLM formaat (het is slechts
#       een MD4 hash, maar beter dan een plaintext wachtwoord in
#       het configuratiebestand op een systeem waar niet gegarandeerd
#       is dat het root account erg veilig is
if not graphical:
    print("\n{}\n{}\n{}{}\n"
          .format("Hieronder wordt gevraagd om gebruikersnaam en (2x) wachtwoord.",
                  "Sluit af met <Enter>.",
                  "Bij het invoeren van het wachtwoord krijg je niets te zien",
                  ", dit hoort zo."))
username = open_question("HU account: ")
pwd_hash = get_pwd_hash("Wachtwoord: ")

# Definieer nieuw configuratieblok voor eduroam;
#   username en pwd_hash worden met behulp van string.format() toegevoegd,
#       daarom moeten ook de open- en sluitaccolades pas dan worden toegevoegd,
#   anders raakt format() in de war
eduroam_config = """{}
network={}
    ssid=\"eduroam\"
    proto=RSN
    key_mgmt=WPA-EAP
    pairwise=CCMP
    auth_alg=OPEN
    eap=PEAP
    identity=\"{}\"
    password=hash:{}
    phase2=\"auth=MSCHAPV2\"
{}
"""

try:
    if wpa_config != "-":
        with open(wpa_config, "a") as f:
            f.write(eduroam_config.format(CONFIG_COMMENT, "{", username, pwd_hash, "}"))
    else:
        show_config("Neem het volgende over in {} (rootrechten nodig):"
                    	.format(DEFAULT_WPA_CONFIG),
                    eduroam_config.format(CONFIG_COMMENT, "{", username, pwd_hash, "}"))

except IOError as e:
    if e.errno == errno.ENOENT:
        # Dit zou nu niet meer mogen gebeuren, er is al succesvol gelezen
        notify("FOUT: Bestand {} niet gevonden".format(wpa_config), True)
        exit(e.errno)
    elif e.errno == errno.EACCES:
        notify("FOUT: Kan bestand {} niet schrijven.\n{} {} {}"
              .format(wpa_config,
                      "Wordt het script wel met rootrechten gedraaid?",
                      "Dit kan met behulp van de applicatielink op de desktop,",
                      "met behulp van sudo of vanuit een root login"), True)
        exit(e.errno)
    else:
        raise

if wpa_config != "-":
    notify("{} aangepast.".format(wpa_config))

if graphical:
    # Cleanup GUI
    root.destroy()
